https://leetcode.com/problems/climbing-stairs/?envType=study-plan-v2&envId=dynamic-programming

You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 

Example 1:

Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Example 2:

Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
 

Constraints:

1 <= n <= 45

Solution Explained: 

1. The base cases are set in the dp vector. dp[0] is set to 0 because there's only one way to climb zero steps (by not climbing at all), and dp[1] is set to 1 because there's only one way to climb one step (by taking one step).

The Solve function is a recursive function that calculates the number of distinct ways to climb i steps, given the dp vector.

Inside Solve, there are two base cases:

2. If i is less than 2 (i.e., i is 0 or 1), the function returns the value stored in dp[i]. These are the base cases of the recursive algorithm.
If dp[i] is not equal to -1, it means that the result for i steps has already been calculated and stored in dp. In this case, the function returns the precomputed value to avoid redundant calculations.
If neither of the base cases is triggered, the function recursively calculates the number of ways to climb i steps by adding the number of ways to climb i-1 steps and the number of ways to climb i-2 steps, plus 1. This is because you can either take one step from i-1 steps or two steps from i-2 steps, and the "+1" accounts for the current step you're taking.

Finally, the Solve function is called with n as its argument to find the number of distinct ways to climb n steps, and the result is returned.

